"""
Stage 3: Vulnerability Identification
- Vulnerability scanning
- Common vulnerability checks
- Custom payload testing
- Analysis of findings
"""

import requests
import urllib.parse
import re
import socket
import ssl
import subprocess
from datetime import datetime
from concurrent.futures import ThreadPoolExecutor


class VulnerabilityStage:
    """Stage 3: Vulnerability Identification"""
    
    def __init__(self, target, config, logger):
        self.target = target
        self.config = config
        self.logger = logger
        self.results = {
            'stage': 'vulnerability',
            'timestamp': datetime.now().isoformat(),
            'success': False,
            'status': 'Starting vulnerability identification...',
            'vulnerabilities': [],
            'web_vulnerabilities': [],
            'ssl_vulnerabilities': [],
            'service_vulnerabilities': [],
            'misconfigurations': [],
            'risk_summary': {
                'critical': 0,
                'high': 0,
                'medium': 0,
                'low': 0,
                'info': 0
            }
        }
        
    def check_ssl_vulnerabilities(self):
        """Check for SSL/TLS vulnerabilities"""
        self.logger.info("Checking SSL/TLS vulnerabilities...")
        
        ssl_vulns = []
        
        # Check if HTTPS is available
        https_ports = [port for port in [443, 8443] if port in self.results.get('ports', {})]
        
        for port in https_ports:
            try:
                # Get SSL certificate info
                context = ssl.create_default_context()
                context.check_hostname = False
                context.verify_mode = ssl.CERT_NONE
                
                with socket.create_connection((self.target, port), timeout=10) as sock:
                    with context.wrap_socket(sock, server_hostname=self.target) as ssock:
                        cert = ssock.getpeercert()
                        cipher = ssock.cipher()
                        version = ssock.version()
                        
                        # Check for weak SSL versions
                        if version in ['SSLv2', 'SSLv3', 'TLSv1', 'TLSv1.1']:
                            ssl_vulns.append({
                                'type': 'Weak SSL/TLS Version',
                                'severity': 'High',
                                'description': f'Server supports weak SSL/TLS version: {version}',
                                'port': port,
                                'evidence': f'SSL Version: {version}'
                            })
                            
                        # Check for weak ciphers
                        if cipher and len(cipher) >= 2:
                            cipher_name = cipher[0]
                            if any(weak in cipher_name.lower() for weak in ['rc4', 'des', 'md5', 'null']):
                                ssl_vulns.append({
                                    'type': 'Weak Cipher Suite',
                                    'severity': 'Medium',
                                    'description': f'Server uses weak cipher: {cipher_name}',
                                    'port': port,
                                    'evidence': f'Cipher: {cipher_name}'
                                })
                                
                        # Check certificate validity
                        if cert:
                            import datetime
                            not_after = datetime.datetime.strptime(cert['notAfter'], '%b %d %H:%M:%S %Y %Z')
                            if not_after < datetime.datetime.now():
                                ssl_vulns.append({
                                    'type': 'Expired SSL Certificate',
                                    'severity': 'Medium',
                                    'description': 'SSL certificate has expired',
                                    'port': port,
                                    'evidence': f'Expired on: {cert["notAfter"]}'
                                })
                                
            except Exception as e:
                self.logger.debug(f"SSL check failed for port {port}: {e}")
                
        self.results['ssl_vulnerabilities'] = ssl_vulns
        return ssl_vulns
        
    def check_web_vulnerabilities(self):
        """Check for common web vulnerabilities"""
        self.logger.info("Checking web vulnerabilities...")
        
        web_vulns = []
        web_ports = [port for port in self.results.get('ports', {}) if port in [80, 443, 8080, 8443]]
        
        for port in web_ports:
            try:
                protocol = 'https' if port in [443, 8443] else 'http'
                base_url = f"{protocol}://{self.target}:{port}" if port not in [80, 443] else f"{protocol}://{self.target}"
                
                # Check for various web vulnerabilities
                web_vulns.extend(self.check_xss_vulnerabilities(base_url))
                web_vulns.extend(self.check_sql_injection(base_url))
                web_vulns.extend(self.check_lfi_vulnerabilities(base_url))
                web_vulns.extend(self.check_directory_traversal(base_url))
                web_vulns.extend(self.check_sensitive_files(base_url))
                web_vulns.extend(self.check_security_headers(base_url))
                
                break  # Only check first working web service
                
            except Exception as e:
                self.logger.debug(f"Web vulnerability check failed: {e}")
                
        self.results['web_vulnerabilities'] = web_vulns
        return web_vulns
        
    def check_xss_vulnerabilities(self, base_url):
        """Check for XSS vulnerabilities"""
        xss_vulns = []
        payloads = self.config.get('payloads', {}).get('xss', ['<script>alert(1)</script>'])
        
        # Test common XSS locations
        test_params = ['q', 'search', 'name', 'id', 'page', 'url', 'redirect']
        
        for param in test_params:
            for payload in payloads:
                try:
                    # Test GET parameter
                    test_url = f"{base_url}/?{param}={urllib.parse.quote(payload)}"
                    headers = {'User-Agent': self.config.get('user_agent', 'ABD/1.0')}
                    
                    response = requests.get(test_url, headers=headers, timeout=10, verify=False)
                    
                    if payload in response.text:
                        xss_vulns.append({
                            'type': 'Reflected XSS',
                            'severity': 'High',
                            'description': f'Reflected XSS vulnerability in parameter: {param}',
                            'url': test_url,
                            'parameter': param,
                            'payload': payload,
                            'evidence': f'Payload reflected in response'
                        })
                        break  # One payload is enough per parameter
                        
                except requests.exceptions.RequestException:
                    pass
                except Exception as e:
                    self.logger.debug(f"XSS check error: {e}")
                    
        return xss_vulns
        
    def check_sql_injection(self, base_url):
        """Check for SQL injection vulnerabilities"""
        sqli_vulns = []
        payloads = self.config.get('payloads', {}).get('sqli', ["'", "' OR '1'='1"])
        
        # SQL error patterns
        error_patterns = [
            r'mysql_fetch_array\(\)',
            r'ORA-\d{5}',
            r'Microsoft.*ODBC.*SQL Server',
            r'PostgreSQL.*ERROR',
            r'Warning.*mysql_.*',
            r'valid MySQL result',
            r'MySqlClient\.',
            r'SQLite/JDBCDriver',
            r'SQLite.Exception',
            r'System.Data.SQLite.SQLiteException',
            r'Warning.*oci_.*',
            r'Warning.*pg_.*'
        ]
        
        test_params = ['id', 'user', 'username', 'page', 'category', 'search']
        
        for param in test_params:
            for payload in payloads:
                try:
                    test_url = f"{base_url}/?{param}={urllib.parse.quote(payload)}"
                    headers = {'User-Agent': self.config.get('user_agent', 'ABD/1.0')}
                    
                    response = requests.get(test_url, headers=headers, timeout=10, verify=False)
                    
                    # Check for SQL error messages
                    for pattern in error_patterns:
                        if re.search(pattern, response.text, re.IGNORECASE):
                            sqli_vulns.append({
                                'type': 'SQL Injection',
                                'severity': 'Critical',
                                'description': f'SQL injection vulnerability in parameter: {param}',
                                'url': test_url,
                                'parameter': param,
                                'payload': payload,
                                'evidence': f'SQL error pattern detected: {pattern}'
                            })
                            break
                            
                except requests.exceptions.RequestException:
                    pass
                except Exception as e:
                    self.logger.debug(f"SQL injection check error: {e}")
                    
        return sqli_vulns
        
    def check_lfi_vulnerabilities(self, base_url):
        """Check for Local File Inclusion vulnerabilities"""
        lfi_vulns = []
        payloads = self.config.get('payloads', {}).get('lfi', ['../../../etc/passwd', '..\\..\\..\\windows\\system32\\drivers\\etc\\hosts'])
        
        # LFI indicators
        lfi_indicators = [
            'root:x:0:0:',
            'daemon:x:1:1:',
            '# localhost',
            '127.0.0.1',
            'Windows NT'
        ]
        
        test_params = ['file', 'page', 'include', 'path', 'doc', 'document']
        
        for param in test_params:
            for payload in payloads:
                try:
                    test_url = f"{base_url}/?{param}={urllib.parse.quote(payload)}"
                    headers = {'User-Agent': self.config.get('user_agent', 'ABD/1.0')}
                    
                    response = requests.get(test_url, headers=headers, timeout=10, verify=False)
                    
                    # Check for LFI indicators
                    for indicator in lfi_indicators:
                        if indicator in response.text:
                            lfi_vulns.append({
                                'type': 'Local File Inclusion',
                                'severity': 'High',
                                'description': f'LFI vulnerability in parameter: {param}',
                                'url': test_url,
                                'parameter': param,
                                'payload': payload,
                                'evidence': f'File content indicator found: {indicator}'
                            })
                            break
                            
                except requests.exceptions.RequestException:
                    pass
                except Exception as e:
                    self.logger.debug(f"LFI check error: {e}")
                    
        return lfi_vulns
        
    def check_directory_traversal(self, base_url):
        """Check for directory traversal vulnerabilities"""
        traversal_vulns = []
        
        # Directory traversal payloads
        payloads = [
            '../', '..\\', '..../', '....\\',
            '%2e%2e%2f', '%2e%2e%5c', '%252e%252e%252f'
        ]
        
        test_paths = [
            'etc/passwd', 'windows/system32/drivers/etc/hosts',
            'boot.ini', 'windows/win.ini'
        ]
        
        for payload in payloads:
            for path in test_paths:
                try:
                    test_path = (payload * 5) + path
                    test_url = f"{base_url}/{test_path}"
                    headers = {'User-Agent': self.config.get('user_agent', 'ABD/1.0')}
                    
                    response = requests.get(test_url, headers=headers, timeout=10, verify=False)
                    
                    # Check for file content indicators
                    if 'root:x:0:0:' in response.text or '# localhost' in response.text:
                        traversal_vulns.append({
                            'type': 'Directory Traversal',
                            'severity': 'High',
                            'description': 'Directory traversal vulnerability detected',
                            'url': test_url,
                            'payload': test_path,
                            'evidence': 'System file content accessible'
                        })
                        break
                        
                except requests.exceptions.RequestException:
                    pass
                except Exception as e:
                    self.logger.debug(f"Directory traversal check error: {e}")
                    
        return traversal_vulns
        
    def check_sensitive_files(self, base_url):
        """Check for sensitive file exposure"""
        sensitive_vulns = []
        
        # Common sensitive files
        sensitive_files = [
            '.env', '.git/config', 'config.php', 'wp-config.php',
            'database.yml', 'settings.py', 'web.config',
            'backup.sql', 'dump.sql', 'phpinfo.php',
            'admin.php', 'test.php', 'debug.php'
        ]
        
        for file_path in sensitive_files:
            try:
                test_url = f"{base_url}/{file_path}"
                headers = {'User-Agent': self.config.get('user_agent', 'ABD/1.0')}
                
                response = requests.get(test_url, headers=headers, timeout=10, verify=False)
                
                if response.status_code == 200 and len(response.content) > 0:
                    # Additional checks for specific file types
                    is_sensitive = False
                    evidence = ""
                    
                    if file_path.endswith('.env') and 'DB_PASSWORD' in response.text:
                        is_sensitive = True
                        evidence = "Environment file with database credentials"
                    elif 'git' in file_path and '[core]' in response.text:
                        is_sensitive = True
                        evidence = "Git configuration file exposed"
                    elif 'config' in file_path and ('password' in response.text.lower() or 'secret' in response.text.lower()):
                        is_sensitive = True
                        evidence = "Configuration file with credentials"
                    elif file_path.endswith('phpinfo.php') and 'PHP Version' in response.text:
                        is_sensitive = True
                        evidence = "PHP information disclosure"
                    elif response.status_code == 200:
                        is_sensitive = True
                        evidence = f"Sensitive file accessible (HTTP {response.status_code})"
                        
                    if is_sensitive:
                        sensitive_vulns.append({
                            'type': 'Sensitive File Exposure',
                            'severity': 'Medium',
                            'description': f'Sensitive file exposed: {file_path}',
                            'url': test_url,
                            'file': file_path,
                            'evidence': evidence
                        })
                        
            except requests.exceptions.RequestException:
                pass
            except Exception as e:
                self.logger.debug(f"Sensitive file check error: {e}")
                
        return sensitive_vulns
        
    def check_security_headers(self, base_url):
        """Check for missing security headers"""
        header_vulns = []
        
        try:
            headers = {'User-Agent': self.config.get('user_agent', 'ABD/1.0')}
            response = requests.get(base_url, headers=headers, timeout=10, verify=False)
            
            # Security headers to check
            security_headers = {
                'X-Frame-Options': 'Missing X-Frame-Options header (Clickjacking protection)',
                'X-XSS-Protection': 'Missing X-XSS-Protection header',
                'X-Content-Type-Options': 'Missing X-Content-Type-Options header (MIME sniffing protection)',
                'Strict-Transport-Security': 'Missing HSTS header (HTTP Strict Transport Security)',
                'Content-Security-Policy': 'Missing Content Security Policy header'
            }
            
            for header, description in security_headers.items():
                if header not in response.headers:
                    header_vulns.append({
                        'type': 'Missing Security Header',
                        'severity': 'Low',
                        'description': description,
                        'url': base_url,
                        'header': header,
                        'evidence': f'Header {header} not present in response'
                    })
                    
        except requests.exceptions.RequestException:
            pass
        except Exception as e:
            self.logger.debug(f"Security header check error: {e}")
            
        return header_vulns
        
    def check_service_vulnerabilities(self):
        """Check for service-specific vulnerabilities"""
        self.logger.info("Checking service vulnerabilities...")
        
        service_vulns = []
        services = self.results.get('services', {})
        
        for port, service_info in services.items():
            service_name = service_info.get('service', '').lower()
            banner = service_info.get('banner', '')
            
            # Check for common vulnerable services
            if service_name == 'ssh' and banner:
                # Check for old SSH versions
                if any(version in banner.lower() for version in ['openssh_4', 'openssh_5', 'openssh_6.0', 'openssh_6.1']):
                    service_vulns.append({
                        'type': 'Vulnerable SSH Version',
                        'severity': 'Medium',
                        'description': 'Outdated SSH version detected',
                        'port': port,
                        'service': service_name,
                        'evidence': f'Banner: {banner}'
                    })
                    
            elif service_name == 'ftp' and banner:
                # Check for anonymous FTP
                try:
                    import ftplib
                    ftp = ftplib.FTP()
                    ftp.connect(self.target, port, timeout=10)
                    ftp.login('anonymous', 'anonymous@test.com')
                    ftp.quit()
                    
                    service_vulns.append({
                        'type': 'Anonymous FTP Access',
                        'severity': 'Medium',
                        'description': 'FTP server allows anonymous access',
                        'port': port,
                        'service': service_name,
                        'evidence': 'Anonymous login successful'
                    })
                except:
                    pass
                    
            elif service_name in ['http', 'https'] and banner:
                # Check for server version disclosure
                if any(server in banner.lower() for server in ['apache/2.2', 'apache/2.0', 'nginx/1.0', 'iis/6.0']):
                    service_vulns.append({
                        'type': 'Server Version Disclosure',
                        'severity': 'Low',
                        'description': 'Web server version disclosed in banner',
                        'port': port,
                        'service': service_name,
                        'evidence': f'Banner: {banner}'
                    })
                    
        self.results['service_vulnerabilities'] = service_vulns
        return service_vulns
        
    def analyze_misconfigurations(self):
        """Analyze for common misconfigurations"""
        self.logger.info("Analyzing misconfigurations...")
        
        misconfigs = []
        
        # Check for open ports that shouldn't be public
        dangerous_ports = {
            22: 'SSH should not be exposed to internet',
            23: 'Telnet is insecure and should not be used',
            21: 'FTP should use SFTP instead',
            135: 'RPC should not be exposed',
            139: 'NetBIOS should not be exposed',
            445: 'SMB should not be exposed',
            1433: 'MSSQL should not be directly exposed',
            3306: 'MySQL should not be directly exposed',
            3389: 'RDP should not be exposed to internet',
            5432: 'PostgreSQL should not be directly exposed'
        }
        
        open_ports = self.results.get('ports', {})
        for port in open_ports:
            if port in dangerous_ports:
                misconfigs.append({
                    'type': 'Dangerous Port Exposure',
                    'severity': 'High',
                    'description': dangerous_ports[port],
                    'port': port,
                    'evidence': f'Port {port} is open and accessible'
                })
                
        # Check for directory listing
        web_ports = [port for port in open_ports if port in [80, 443, 8080, 8443]]
        for port in web_ports:
            try:
                protocol = 'https' if port in [443, 8443] else 'http'
                base_url = f"{protocol}://{self.target}:{port}" if port not in [80, 443] else f"{protocol}://{self.target}"
                
                headers = {'User-Agent': self.config.get('user_agent', 'ABD/1.0')}
                response = requests.get(base_url, headers=headers, timeout=10, verify=False)
                
                if 'Index of /' in response.text or 'Directory Listing' in response.text:
                    misconfigs.append({
                        'type': 'Directory Listing Enabled',
                        'severity': 'Medium',
                        'description': 'Web server has directory listing enabled',
                        'url': base_url,
                        'evidence': 'Directory listing detected in response'
                    })
                    
            except:
                pass
                
        self.results['misconfigurations'] = misconfigs
        return misconfigs
        
    def calculate_risk_summary(self):
        """Calculate overall risk summary"""
        all_vulns = (
            self.results.get('web_vulnerabilities', []) +
            self.results.get('ssl_vulnerabilities', []) +
            self.results.get('service_vulnerabilities', []) +
            self.results.get('misconfigurations', [])
        )
        
        risk_summary = {'critical': 0, 'high': 0, 'medium': 0, 'low': 0, 'info': 0}
        
        for vuln in all_vulns:
            severity = vuln.get('severity', 'info').lower()
            if severity in risk_summary:
                risk_summary[severity] += 1
                
        self.results['risk_summary'] = risk_summary
        self.results['vulnerabilities'] = all_vulns
        
        return risk_summary
        
    def execute(self):
        """Execute the vulnerability identification stage"""
        self.logger.info("═══ STAGE 3: VULNERABILITY IDENTIFICATION ═══")
        
        try:
            # Get reconnaissance results
            from .reconnaissance import ReconnaissanceStage
            recon_results = getattr(self, 'recon_results', {})
            if 'ports' in recon_results:
                self.results.update(recon_results)
            
            # Step 1: SSL/TLS vulnerability checks
            self.check_ssl_vulnerabilities()
            
            # Step 2: Web vulnerability checks
            self.check_web_vulnerabilities()
            
            # Step 3: Service vulnerability checks
            self.check_service_vulnerabilities()
            
            # Step 4: Misconfiguration analysis
            self.analyze_misconfigurations()
            
            # Step 5: Calculate risk summary
            risk_summary = self.calculate_risk_summary()
            
            # Mark as successful
            self.results['success'] = True
            self.results['status'] = 'Vulnerability identification completed successfully'
            
            # Summary
            total_vulns = sum(risk_summary.values())
            critical_high = risk_summary['critical'] + risk_summary['high']
            
            self.logger.success(f"Vulnerability scan completed: {total_vulns} total findings, {critical_high} critical/high severity")
            
        except Exception as e:
            self.results['status'] = f'Vulnerability identification failed: {str(e)}'
            self.logger.error(f"Vulnerability identification stage failed: {e}")
            
        return self.results