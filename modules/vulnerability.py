"""
Stage 3: Vulnerability Identification
- Vulnerability scanning
- Common vulnerability checks
- Custom payload testing
- Analysis of findings
"""

import requests
import urllib.parse
import re
import socket
import ssl
import subprocess
from datetime import datetime
from concurrent.futures import ThreadPoolExecutor


class VulnerabilityStage:
    """Stage 3: Vulnerability Identification"""
    
    def __init__(self, target, config, logger):
        self.target = target
        self.config = config
        self.logger = logger
        self.results = {
            'stage': 'vulnerability',
            'timestamp': datetime.now().isoformat(),
            'success': False,
            'status': 'Starting vulnerability identification...',
            'vulnerabilities': [],
            'web_vulnerabilities': [],
            'ssl_vulnerabilities': [],
            'service_vulnerabilities': [],
            'misconfigurations': [],
            'risk_summary': {
                'critical': 0,
                'high': 0,
                'medium': 0,
                'low': 0,
                'info': 0
            }
        }
        
    def check_ssl_vulnerabilities(self):
        """Check for SSL/TLS vulnerabilities"""
        self.logger.info("Checking SSL/TLS vulnerabilities...")
        
        ssl_vulns = []
        
        # Check if HTTPS is available
        https_ports = [port for port in [443, 8443] if port in self.results.get('ports', {})]
        
        for port in https_ports:
            try:
                # Get SSL certificate info
                context = ssl.create_default_context()
                context.check_hostname = False
                context.verify_mode = ssl.CERT_NONE
                
                with socket.create_connection((self.target, port), timeout=10) as sock:
                    with context.wrap_socket(sock, server_hostname=self.target) as ssock:
                        cert = ssock.getpeercert()
                        cipher = ssock.cipher()
                        version = ssock.version()
                        
                        # Check for weak SSL versions
                        if version in ['SSLv2', 'SSLv3', 'TLSv1', 'TLSv1.1']:
                            ssl_vulns.append({
                                'type': 'Weak SSL/TLS Version',
                                'severity': 'High',
                                'description': f'Server supports weak SSL/TLS version: {version}',
                                'port': port,
                                'evidence': f'SSL Version: {version}'
                            })
                            
                        # Check for weak ciphers
                        if cipher and len(cipher) >= 2:
                            cipher_name = cipher[0]
                            if any(weak in cipher_name.lower() for weak in ['rc4', 'des', 'md5', 'null']):
                                ssl_vulns.append({
                                    'type': 'Weak Cipher Suite',
                                    'severity': 'Medium',
                                    'description': f'Server uses weak cipher: {cipher_name}',
                                    'port': port,
                                    'evidence': f'Cipher: {cipher_name}'
                                })
                                
                        # Check certificate validity
                        if cert:
                            import datetime
                            not_after = datetime.datetime.strptime(cert['notAfter'], '%b %d %H:%M:%S %Y %Z')
                            if not_after < datetime.datetime.now():
                                ssl_vulns.append({
                                    'type': 'Expired SSL Certificate',
                                    'severity': 'Medium',
                                    'description': 'SSL certificate has expired',
                                    'port': port,
                                    'evidence': f'Expired on: {cert["notAfter"]}'
                                })
                                
            except Exception as e:
                self.logger.debug(f"SSL check failed for port {port}: {e}")
                
        self.results['ssl_vulnerabilities'] = ssl_vulns
        return ssl_vulns
        
    def check_web_vulnerabilities(self):
        """Check for common web vulnerabilities"""
        self.logger.info("Checking web vulnerabilities...")
        
        web_vulns = []
        web_ports = [port for port in self.results.get('ports', {}) if port in [80, 443, 8080, 8443]]
        
        for port in web_ports:
            try:
                protocol = 'https' if port in [443, 8443] else 'http'
                base_url = f"{protocol}://{self.target}:{port}" if port not in [80, 443] else f"{protocol}://{self.target}"
                
                # Check for various web vulnerabilities
                web_vulns.extend(self.check_xss_vulnerabilities(base_url))
                web_vulns.extend(self.check_sql_injection(base_url))
                web_vulns.extend(self.check_nosql_injection(base_url))
                web_vulns.extend(self.check_lfi_vulnerabilities(base_url))
                web_vulns.extend(self.check_directory_traversal(base_url))
                web_vulns.extend(self.check_sensitive_files(base_url))
                web_vulns.extend(self.check_security_headers(base_url))
                web_vulns.extend(self.check_xxe_vulnerabilities(base_url))
                web_vulns.extend(self.check_ssrf_vulnerabilities(base_url))
                web_vulns.extend(self.check_ssti_vulnerabilities(base_url))
                web_vulns.extend(self.check_ldap_injection(base_url))
                web_vulns.extend(self.check_idor_vulnerabilities(base_url))
                web_vulns.extend(self.check_csrf_vulnerabilities(base_url))
                web_vulns.extend(self.check_cors_misconfigurations(base_url))
                web_vulns.extend(self.check_host_header_injection(base_url))
                web_vulns.extend(self.check_file_upload_vulnerabilities(base_url))
                web_vulns.extend(self.check_subdomain_takeover())
                
                break  # Only check first working web service
                
            except Exception as e:
                self.logger.debug(f"Web vulnerability check failed: {e}")
                
        self.results['web_vulnerabilities'] = web_vulns
        return web_vulns
        
    def check_xss_vulnerabilities(self, base_url):
        """Check for XSS vulnerabilities"""
        xss_vulns = []
        payloads = self.config.get('payloads', {}).get('xss', ['<script>alert(1)</script>'])
        
        # Test common XSS locations
        test_params = ['q', 'search', 'name', 'id', 'page', 'url', 'redirect']
        
        for param in test_params:
            for payload in payloads:
                try:
                    # Test GET parameter
                    test_url = f"{base_url}/?{param}={urllib.parse.quote(payload)}"
                    headers = {'User-Agent': self.config.get('user_agent', 'ABD/1.0')}
                    
                    response = requests.get(test_url, headers=headers, timeout=10, verify=False)
                    
                    if payload in response.text:
                        xss_vulns.append({
                            'type': 'Reflected XSS',
                            'severity': 'High',
                            'description': f'Reflected XSS vulnerability in parameter: {param}',
                            'url': test_url,
                            'parameter': param,
                            'payload': payload,
                            'evidence': f'Payload reflected in response'
                        })
                        break  # One payload is enough per parameter
                        
                except requests.exceptions.RequestException:
                    pass
                except Exception as e:
                    self.logger.debug(f"XSS check error: {e}")
                    
        return xss_vulns
        
    def check_sql_injection(self, base_url):
        """Check for SQL injection vulnerabilities"""
        sqli_vulns = []
        payloads = self.config.get('payloads', {}).get('sqli', ["'", "' OR '1'='1"])
        
        # SQL error patterns
        error_patterns = [
            r'mysql_fetch_array\(\)',
            r'ORA-\d{5}',
            r'Microsoft.*ODBC.*SQL Server',
            r'PostgreSQL.*ERROR',
            r'Warning.*mysql_.*',
            r'valid MySQL result',
            r'MySqlClient\.',
            r'SQLite/JDBCDriver',
            r'SQLite.Exception',
            r'System.Data.SQLite.SQLiteException',
            r'Warning.*oci_.*',
            r'Warning.*pg_.*'
        ]
        
        test_params = ['id', 'user', 'username', 'page', 'category', 'search']
        
        for param in test_params:
            for payload in payloads:
                try:
                    test_url = f"{base_url}/?{param}={urllib.parse.quote(payload)}"
                    headers = {'User-Agent': self.config.get('user_agent', 'ABD/1.0')}
                    
                    response = requests.get(test_url, headers=headers, timeout=10, verify=False)
                    
                    # Check for SQL error messages
                    for pattern in error_patterns:
                        if re.search(pattern, response.text, re.IGNORECASE):
                            sqli_vulns.append({
                                'type': 'SQL Injection',
                                'severity': 'Critical',
                                'description': f'SQL injection vulnerability in parameter: {param}',
                                'url': test_url,
                                'parameter': param,
                                'payload': payload,
                                'evidence': f'SQL error pattern detected: {pattern}'
                            })
                            break
                            
                except requests.exceptions.RequestException:
                    pass
                except Exception as e:
                    self.logger.debug(f"SQL injection check error: {e}")
                    
        return sqli_vulns
        
    def check_lfi_vulnerabilities(self, base_url):
        """Check for Local File Inclusion vulnerabilities"""
        lfi_vulns = []
        payloads = self.config.get('payloads', {}).get('lfi', ['../../../etc/passwd', '..\\..\\..\\windows\\system32\\drivers\\etc\\hosts'])
        
        # LFI indicators
        lfi_indicators = [
            'root:x:0:0:',
            'daemon:x:1:1:',
            '# localhost',
            '127.0.0.1',
            'Windows NT'
        ]
        
        test_params = ['file', 'page', 'include', 'path', 'doc', 'document']
        
        for param in test_params:
            for payload in payloads:
                try:
                    test_url = f"{base_url}/?{param}={urllib.parse.quote(payload)}"
                    headers = {'User-Agent': self.config.get('user_agent', 'ABD/1.0')}
                    
                    response = requests.get(test_url, headers=headers, timeout=10, verify=False)
                    
                    # Check for LFI indicators
                    for indicator in lfi_indicators:
                        if indicator in response.text:
                            lfi_vulns.append({
                                'type': 'Local File Inclusion',
                                'severity': 'High',
                                'description': f'LFI vulnerability in parameter: {param}',
                                'url': test_url,
                                'parameter': param,
                                'payload': payload,
                                'evidence': f'File content indicator found: {indicator}'
                            })
                            break
                            
                except requests.exceptions.RequestException:
                    pass
                except Exception as e:
                    self.logger.debug(f"LFI check error: {e}")
                    
        return lfi_vulns
        
    def check_directory_traversal(self, base_url):
        """Check for directory traversal vulnerabilities"""
        traversal_vulns = []
        
        # Directory traversal payloads
        payloads = [
            '../', '..\\', '..../', '....\\',
            '%2e%2e%2f', '%2e%2e%5c', '%252e%252e%252f'
        ]
        
        test_paths = [
            'etc/passwd', 'windows/system32/drivers/etc/hosts',
            'boot.ini', 'windows/win.ini'
        ]
        
        for payload in payloads:
            for path in test_paths:
                try:
                    test_path = (payload * 5) + path
                    test_url = f"{base_url}/{test_path}"
                    headers = {'User-Agent': self.config.get('user_agent', 'ABD/1.0')}
                    
                    response = requests.get(test_url, headers=headers, timeout=10, verify=False)
                    
                    # Check for file content indicators
                    if 'root:x:0:0:' in response.text or '# localhost' in response.text:
                        traversal_vulns.append({
                            'type': 'Directory Traversal',
                            'severity': 'High',
                            'description': 'Directory traversal vulnerability detected',
                            'url': test_url,
                            'payload': test_path,
                            'evidence': 'System file content accessible'
                        })
                        break
                        
                except requests.exceptions.RequestException:
                    pass
                except Exception as e:
                    self.logger.debug(f"Directory traversal check error: {e}")
                    
        return traversal_vulns
        
    def check_sensitive_files(self, base_url):
        """Check for sensitive file exposure"""
        sensitive_vulns = []
        
        # Common sensitive files
        sensitive_files = [
            '.env', '.git/config', 'config.php', 'wp-config.php',
            'database.yml', 'settings.py', 'web.config',
            'backup.sql', 'dump.sql', 'phpinfo.php',
            'admin.php', 'test.php', 'debug.php'
        ]
        
        for file_path in sensitive_files:
            try:
                test_url = f"{base_url}/{file_path}"
                headers = {'User-Agent': self.config.get('user_agent', 'ABD/1.0')}
                
                response = requests.get(test_url, headers=headers, timeout=10, verify=False)
                
                if response.status_code == 200 and len(response.content) > 0:
                    # Additional checks for specific file types
                    is_sensitive = False
                    evidence = ""
                    
                    if file_path.endswith('.env') and 'DB_PASSWORD' in response.text:
                        is_sensitive = True
                        evidence = "Environment file with database credentials"
                    elif 'git' in file_path and '[core]' in response.text:
                        is_sensitive = True
                        evidence = "Git configuration file exposed"
                    elif 'config' in file_path and ('password' in response.text.lower() or 'secret' in response.text.lower()):
                        is_sensitive = True
                        evidence = "Configuration file with credentials"
                    elif file_path.endswith('phpinfo.php') and 'PHP Version' in response.text:
                        is_sensitive = True
                        evidence = "PHP information disclosure"
                    elif response.status_code == 200:
                        is_sensitive = True
                        evidence = f"Sensitive file accessible (HTTP {response.status_code})"
                        
                    if is_sensitive:
                        sensitive_vulns.append({
                            'type': 'Sensitive File Exposure',
                            'severity': 'Medium',
                            'description': f'Sensitive file exposed: {file_path}',
                            'url': test_url,
                            'file': file_path,
                            'evidence': evidence
                        })
                        
            except requests.exceptions.RequestException:
                pass
            except Exception as e:
                self.logger.debug(f"Sensitive file check error: {e}")
                
        return sensitive_vulns
        
    def check_security_headers(self, base_url):
        """Check for missing security headers"""
        header_vulns = []
        
        try:
            headers = {'User-Agent': self.config.get('user_agent', 'ABD/1.0')}
            response = requests.get(base_url, headers=headers, timeout=10, verify=False)
            
            # Security headers to check
            security_headers = {
                'X-Frame-Options': 'Missing X-Frame-Options header (Clickjacking protection)',
                'X-XSS-Protection': 'Missing X-XSS-Protection header',
                'X-Content-Type-Options': 'Missing X-Content-Type-Options header (MIME sniffing protection)',
                'Strict-Transport-Security': 'Missing HSTS header (HTTP Strict Transport Security)',
                'Content-Security-Policy': 'Missing Content Security Policy header'
            }
            
            for header, description in security_headers.items():
                if header not in response.headers:
                    header_vulns.append({
                        'type': 'Missing Security Header',
                        'severity': 'Low',
                        'description': description,
                        'url': base_url,
                        'header': header,
                        'evidence': f'Header {header} not present in response'
                    })
                    
        except requests.exceptions.RequestException:
            pass
        except Exception as e:
            self.logger.debug(f"Security header check error: {e}")
            
        return header_vulns
        
    def check_service_vulnerabilities(self):
        """Check for service-specific vulnerabilities"""
        self.logger.info("Checking service vulnerabilities...")
        
        service_vulns = []
        services = self.results.get('services', {})
        
        for port, service_info in services.items():
            service_name = service_info.get('service', '').lower()
            banner = service_info.get('banner', '')
            
            # Check for common vulnerable services
            if service_name == 'ssh' and banner:
                # Check for old SSH versions
                if any(version in banner.lower() for version in ['openssh_4', 'openssh_5', 'openssh_6.0', 'openssh_6.1']):
                    service_vulns.append({
                        'type': 'Vulnerable SSH Version',
                        'severity': 'Medium',
                        'description': 'Outdated SSH version detected',
                        'port': port,
                        'service': service_name,
                        'evidence': f'Banner: {banner}'
                    })
                    
            elif service_name == 'ftp' and banner:
                # Check for anonymous FTP
                try:
                    import ftplib
                    ftp = ftplib.FTP()
                    ftp.connect(self.target, port, timeout=10)
                    ftp.login('anonymous', 'anonymous@test.com')
                    ftp.quit()
                    
                    service_vulns.append({
                        'type': 'Anonymous FTP Access',
                        'severity': 'Medium',
                        'description': 'FTP server allows anonymous access',
                        'port': port,
                        'service': service_name,
                        'evidence': 'Anonymous login successful'
                    })
                except:
                    pass
                    
            elif service_name in ['http', 'https'] and banner:
                # Check for server version disclosure
                if any(server in banner.lower() for server in ['apache/2.2', 'apache/2.0', 'nginx/1.0', 'iis/6.0']):
                    service_vulns.append({
                        'type': 'Server Version Disclosure',
                        'severity': 'Low',
                        'description': 'Web server version disclosed in banner',
                        'port': port,
                        'service': service_name,
                        'evidence': f'Banner: {banner}'
                    })
                    
        self.results['service_vulnerabilities'] = service_vulns
        return service_vulns
        
    def analyze_misconfigurations(self):
        """Analyze for common misconfigurations"""
        self.logger.info("Analyzing misconfigurations...")
        
        misconfigs = []
        
        # Check for open ports that shouldn't be public
        dangerous_ports = {
            22: 'SSH should not be exposed to internet',
            23: 'Telnet is insecure and should not be used',
            21: 'FTP should use SFTP instead',
            135: 'RPC should not be exposed',
            139: 'NetBIOS should not be exposed',
            445: 'SMB should not be exposed',
            1433: 'MSSQL should not be directly exposed',
            3306: 'MySQL should not be directly exposed',
            3389: 'RDP should not be exposed to internet',
            5432: 'PostgreSQL should not be directly exposed'
        }
        
        open_ports = self.results.get('ports', {})
        for port in open_ports:
            if port in dangerous_ports:
                misconfigs.append({
                    'type': 'Dangerous Port Exposure',
                    'severity': 'High',
                    'description': dangerous_ports[port],
                    'port': port,
                    'evidence': f'Port {port} is open and accessible'
                })
                
        # Check for directory listing
        web_ports = [port for port in open_ports if port in [80, 443, 8080, 8443]]
        for port in web_ports:
            try:
                protocol = 'https' if port in [443, 8443] else 'http'
                base_url = f"{protocol}://{self.target}:{port}" if port not in [80, 443] else f"{protocol}://{self.target}"
                
                headers = {'User-Agent': self.config.get('user_agent', 'ABD/1.0')}
                response = requests.get(base_url, headers=headers, timeout=10, verify=False)
                
                if 'Index of /' in response.text or 'Directory Listing' in response.text:
                    misconfigs.append({
                        'type': 'Directory Listing Enabled',
                        'severity': 'Medium',
                        'description': 'Web server has directory listing enabled',
                        'url': base_url,
                        'evidence': 'Directory listing detected in response'
                    })
                    
            except:
                pass
                
        self.results['misconfigurations'] = misconfigs
        return misconfigs

    def check_nosql_injection(self, base_url):
        """Check for NoSQL injection vulnerabilities"""
        nosql_vulns = []
        payloads = self.config.get('payloads', {}).get('nosqli', ['true, $where: \'1 == 1\'', '$ne: null'])
        
        # NoSQL error patterns
        error_patterns = [
            r'MongoError',
            r'CouchDB',
            r'ReferenceError.*is not defined',
            r'SyntaxError.*Unexpected token',
            r'mongodb.*error',
            r'cassandra.*error'
        ]
        
        test_params = ['id', 'user', 'username', 'search', 'filter']
        
        for param in test_params:
            for payload in payloads:
                try:
                    test_url = f"{base_url}/?{param}={urllib.parse.quote(str(payload))}"
                    headers = {'User-Agent': self.config.get('user_agent', 'ABD/1.0')}
                    
                    response = requests.get(test_url, headers=headers, timeout=10, verify=False)
                    
                    # Check for NoSQL error messages
                    for pattern in error_patterns:
                        if re.search(pattern, response.text, re.IGNORECASE):
                            nosql_vulns.append({
                                'type': 'NoSQL Injection',
                                'severity': 'Critical',
                                'description': f'NoSQL injection vulnerability in parameter: {param}',
                                'url': test_url,
                                'parameter': param,
                                'payload': payload,
                                'evidence': f'NoSQL error pattern detected: {pattern}'
                            })
                            break
                            
                except requests.exceptions.RequestException:
                    pass
                except Exception as e:
                    self.logger.debug(f"NoSQL injection check error: {e}")
                    
        return nosql_vulns

    def check_xxe_vulnerabilities(self, base_url):
        """Check for XML External Entity vulnerabilities"""
        xxe_vulns = []
        payloads = self.config.get('payloads', {}).get('xxe', [])
        
        # XXE indicators
        xxe_indicators = [
            'root:x:0:0:',
            'daemon:x:1:1:',
            'ENTITY',
            'DOCTYPE'
        ]
        
        # Common XML endpoints
        xml_paths = ['/xml', '/api/xml', '/upload', '/import', '/export']
        
        for path in xml_paths:
            for payload in payloads:
                try:
                    test_url = f"{base_url}{path}"
                    headers = {
                        'User-Agent': self.config.get('user_agent', 'ABD/1.0'),
                        'Content-Type': 'application/xml'
                    }
                    
                    response = requests.post(test_url, data=payload, headers=headers, timeout=10, verify=False)
                    
                    # Check for XXE indicators
                    for indicator in xxe_indicators:
                        if indicator in response.text:
                            xxe_vulns.append({
                                'type': 'XML External Entity (XXE)',
                                'severity': 'Critical',
                                'description': 'XXE vulnerability detected',
                                'url': test_url,
                                'payload': payload[:100] + '...' if len(payload) > 100 else payload,
                                'evidence': f'XXE indicator found: {indicator}'
                            })
                            break
                            
                except requests.exceptions.RequestException:
                    pass
                except Exception as e:
                    self.logger.debug(f"XXE check error: {e}")
                    
        return xxe_vulns

    def check_ssrf_vulnerabilities(self, base_url):
        """Check for Server-Side Request Forgery vulnerabilities"""
        ssrf_vulns = []
        payloads = self.config.get('payloads', {}).get('ssrf', ['http://127.0.0.1:22'])
        
        # SSRF-prone parameters
        ssrf_params = ['url', 'link', 'src', 'source', 'target', 'redirect', 'uri', 'path', 'continue', 'dest', 'destination']
        
        for param in ssrf_params:
            for payload in payloads:
                try:
                    test_url = f"{base_url}/?{param}={urllib.parse.quote(payload)}"
                    headers = {'User-Agent': self.config.get('user_agent', 'ABD/1.0')}
                    
                    # Use a longer timeout to detect SSRF delays
                    response = requests.get(test_url, headers=headers, timeout=15, verify=False)
                    
                    # Check for SSRF indicators
                    ssrf_indicators = [
                        'Connection refused',
                        'Connection timed out',
                        'No route to host',
                        'Permission denied',
                        'Internal Server Error',
                        'AWS',
                        'metadata'
                    ]
                    
                    for indicator in ssrf_indicators:
                        if indicator in response.text:
                            ssrf_vulns.append({
                                'type': 'Server-Side Request Forgery (SSRF)',
                                'severity': 'Critical',
                                'description': f'SSRF vulnerability in parameter: {param}',
                                'url': test_url,
                                'parameter': param,
                                'payload': payload,
                                'evidence': f'SSRF indicator found: {indicator}'
                            })
                            break
                            
                except requests.exceptions.Timeout:
                    # Timeout could indicate SSRF
                    ssrf_vulns.append({
                        'type': 'Server-Side Request Forgery (SSRF)',
                        'severity': 'High',
                        'description': f'Potential SSRF in parameter: {param} (timeout)',
                        'url': test_url,
                        'parameter': param,
                        'payload': payload,
                        'evidence': 'Request timeout suggests SSRF'
                    })
                except requests.exceptions.RequestException:
                    pass
                except Exception as e:
                    self.logger.debug(f"SSRF check error: {e}")
                    
        return ssrf_vulns

    def check_ssti_vulnerabilities(self, base_url):
        """Check for Server-Side Template Injection vulnerabilities"""
        ssti_vulns = []
        payloads = self.config.get('payloads', {}).get('ssti', ['{{7*7}}', '${7*7}'])
        
        # SSTI result patterns
        ssti_patterns = {
            '{{7*7}}': '49',
            '${7*7}': '49',
            '<%=7*7%>': '49'
        }
        
        test_params = ['name', 'template', 'content', 'message', 'comment', 'text']
        
        for param in test_params:
            for payload in payloads:
                try:
                    test_url = f"{base_url}/?{param}={urllib.parse.quote(payload)}"
                    headers = {'User-Agent': self.config.get('user_agent', 'ABD/1.0')}
                    
                    response = requests.get(test_url, headers=headers, timeout=10, verify=False)
                    
                    # Check for SSTI evaluation
                    expected_result = ssti_patterns.get(payload, '49')
                    if expected_result in response.text and payload not in response.text:
                        ssti_vulns.append({
                            'type': 'Server-Side Template Injection (SSTI)',
                            'severity': 'Critical',
                            'description': f'SSTI vulnerability in parameter: {param}',
                            'url': test_url,
                            'parameter': param,
                            'payload': payload,
                            'evidence': f'Template evaluation detected: {expected_result}'
                        })
                        break
                        
                except requests.exceptions.RequestException:
                    pass
                except Exception as e:
                    self.logger.debug(f"SSTI check error: {e}")
                    
        return ssti_vulns

    def check_ldap_injection(self, base_url):
        """Check for LDAP injection vulnerabilities"""
        ldap_vulns = []
        payloads = self.config.get('payloads', {}).get('ldap', ['*', '*)(&'])
        
        # LDAP error patterns
        ldap_patterns = [
            r'LdapErr',
            r'LDAP.*error',
            r'javax.naming.directory',
            r'LDAPException',
            r'com.sun.jndi.ldap'
        ]
        
        test_params = ['username', 'user', 'uid', 'login', 'email', 'search']
        
        for param in test_params:
            for payload in payloads:
                try:
                    test_url = f"{base_url}/?{param}={urllib.parse.quote(payload)}"
                    headers = {'User-Agent': self.config.get('user_agent', 'ABD/1.0')}
                    
                    response = requests.get(test_url, headers=headers, timeout=10, verify=False)
                    
                    # Check for LDAP error messages
                    for pattern in ldap_patterns:
                        if re.search(pattern, response.text, re.IGNORECASE):
                            ldap_vulns.append({
                                'type': 'LDAP Injection',
                                'severity': 'High',
                                'description': f'LDAP injection vulnerability in parameter: {param}',
                                'url': test_url,
                                'parameter': param,
                                'payload': payload,
                                'evidence': f'LDAP error pattern detected: {pattern}'
                            })
                            break
                            
                except requests.exceptions.RequestException:
                    pass
                except Exception as e:
                    self.logger.debug(f"LDAP injection check error: {e}")
                    
        return ldap_vulns

    def check_idor_vulnerabilities(self, base_url):
        """Check for Insecure Direct Object Reference vulnerabilities"""
        idor_vulns = []
        
        # Common IDOR-prone endpoints
        idor_paths = [
            '/user/1', '/user/2',
            '/profile/1', '/profile/2',
            '/account/1', '/account/2',
            '/order/1', '/order/2',
            '/document/1', '/document/2',
            '/file/1', '/file/2'
        ]
        
        for i, path in enumerate(idor_paths):
            if i % 2 == 0:  # Check pairs
                try:
                    test_url1 = f"{base_url}{path}"
                    test_url2 = f"{base_url}{idor_paths[i+1]}" if i+1 < len(idor_paths) else None
                    
                    headers = {'User-Agent': self.config.get('user_agent', 'ABD/1.0')}
                    
                    response1 = requests.get(test_url1, headers=headers, timeout=10, verify=False)
                    
                    if test_url2:
                        response2 = requests.get(test_url2, headers=headers, timeout=10, verify=False)
                        
                        # If both return 200 but different content, potential IDOR
                        if (response1.status_code == 200 and response2.status_code == 200 and 
                            response1.text != response2.text and len(response1.text) > 100):
                            idor_vulns.append({
                                'type': 'Insecure Direct Object Reference (IDOR)',
                                'severity': 'High',
                                'description': 'Potential IDOR vulnerability detected',
                                'url': test_url1,
                                'evidence': f'Different responses for {path} and {idor_paths[i+1]}'
                            })
                            
                except requests.exceptions.RequestException:
                    pass
                except Exception as e:
                    self.logger.debug(f"IDOR check error: {e}")
                    
        return idor_vulns

    def check_csrf_vulnerabilities(self, base_url):
        """Check for Cross-Site Request Forgery vulnerabilities"""
        csrf_vulns = []
        
        # Common form endpoints
        form_paths = ['/login', '/register', '/contact', '/admin', '/profile', '/settings']
        
        for path in form_paths:
            try:
                test_url = f"{base_url}{path}"
                headers = {'User-Agent': self.config.get('user_agent', 'ABD/1.0')}
                
                response = requests.get(test_url, headers=headers, timeout=10, verify=False)
                
                if response.status_code == 200:
                    # Check for CSRF tokens
                    csrf_indicators = [
                        'csrf_token',
                        'csrftoken',
                        '_token',
                        'authenticity_token',
                        'anti-forgery-token'
                    ]
                    
                    has_csrf_protection = any(indicator in response.text.lower() for indicator in csrf_indicators)
                    
                    # Check for forms without CSRF protection
                    if '<form' in response.text.lower() and not has_csrf_protection:
                        csrf_vulns.append({
                            'type': 'Cross-Site Request Forgery (CSRF)',
                            'severity': 'Medium',
                            'description': 'Form without CSRF protection detected',
                            'url': test_url,
                            'evidence': 'Form found without CSRF token'
                        })
                        
            except requests.exceptions.RequestException:
                pass
            except Exception as e:
                self.logger.debug(f"CSRF check error: {e}")
                
        return csrf_vulns

    def check_cors_misconfigurations(self, base_url):
        """Check for CORS misconfigurations"""
        cors_vulns = []
        
        try:
            # Test with dangerous origins
            dangerous_origins = [
                'http://evil.com',
                'null',
                'http://localhost:3000'
            ]
            
            for origin in dangerous_origins:
                headers = {
                    'User-Agent': self.config.get('user_agent', 'ABD/1.0'),
                    'Origin': origin
                }
                
                response = requests.get(base_url, headers=headers, timeout=10, verify=False)
                
                # Check CORS headers
                acao = response.headers.get('Access-Control-Allow-Origin', '')
                acac = response.headers.get('Access-Control-Allow-Credentials', '')
                
                if acao == '*' and acac.lower() == 'true':
                    cors_vulns.append({
                        'type': 'CORS Misconfiguration',
                        'severity': 'High',
                        'description': 'Dangerous CORS policy: wildcard origin with credentials',
                        'url': base_url,
                        'evidence': 'Access-Control-Allow-Origin: * with Allow-Credentials: true'
                    })
                elif acao == origin:
                    cors_vulns.append({
                        'type': 'CORS Misconfiguration',
                        'severity': 'Medium',
                        'description': f'CORS allows arbitrary origin: {origin}',
                        'url': base_url,
                        'evidence': f'Access-Control-Allow-Origin: {origin}'
                    })
                    
        except requests.exceptions.RequestException:
            pass
        except Exception as e:
            self.logger.debug(f"CORS check error: {e}")
            
        return cors_vulns

    def check_host_header_injection(self, base_url):
        """Check for Host header injection vulnerabilities"""
        host_injection_vulns = []
        
        # Malicious hosts to test
        malicious_hosts = [
            'evil.com',
            'localhost',
            '127.0.0.1:8080'
        ]
        
        for malicious_host in malicious_hosts:
            try:
                headers = {
                    'User-Agent': self.config.get('user_agent', 'ABD/1.0'),
                    'Host': malicious_host
                }
                
                response = requests.get(base_url, headers=headers, timeout=10, verify=False)
                
                # Check if malicious host appears in response
                if malicious_host in response.text:
                    host_injection_vulns.append({
                        'type': 'Host Header Injection',
                        'severity': 'Medium',
                        'description': 'Host header injection vulnerability detected',
                        'url': base_url,
                        'evidence': f'Malicious host {malicious_host} reflected in response'
                    })
                    break
                    
            except requests.exceptions.RequestException:
                pass
            except Exception as e:
                self.logger.debug(f"Host header injection check error: {e}")
                
        return host_injection_vulns

    def check_file_upload_vulnerabilities(self, base_url):
        """Check for file upload vulnerabilities"""
        upload_vulns = []
        
        # Common upload endpoints
        upload_paths = ['/upload', '/file-upload', '/import', '/avatar', '/profile-picture']
        
        for path in upload_paths:
            try:
                test_url = f"{base_url}{path}"
                headers = {'User-Agent': self.config.get('user_agent', 'ABD/1.0')}
                
                response = requests.get(test_url, headers=headers, timeout=10, verify=False)
                
                if response.status_code == 200:
                    # Check for file upload forms
                    if 'type="file"' in response.text.lower():
                        upload_vulns.append({
                            'type': 'File Upload Endpoint',
                            'severity': 'Medium',
                            'description': 'File upload endpoint detected - requires manual testing',
                            'url': test_url,
                            'evidence': 'File input field found'
                        })
                        
            except requests.exceptions.RequestException:
                pass
            except Exception as e:
                self.logger.debug(f"File upload check error: {e}")
                
        return upload_vulns

    def check_subdomain_takeover(self):
        """Check for subdomain takeover vulnerabilities"""
        takeover_vulns = []
        
        # This would require subdomain enumeration from reconnaissance stage
        subdomains = self.results.get('subdomains', [])
        
        # Known vulnerable CNAME patterns
        vulnerable_patterns = [
            'github.io',
            'herokuapp.com',
            'wordpress.com',
            'tumblr.com',
            'bitbucket.io',
            'ghost.io',
            'helpjuice.com',
            'helpscoutdocs.com',
            'desk.com',
            'teamwork.com',
            'unbounce.com',
            'instapage.com',
            'tictail.com',
            'campaignmonitor.com',
            'acquia-test.co',
            'proposify.biz',
            'simplebooklet.com',
            'gr8.com'
        ]
        
        for subdomain in subdomains[:10]:  # Limit to first 10 subdomains
            try:
                import dns.resolver
                answers = dns.resolver.resolve(subdomain, 'CNAME')
                for answer in answers:
                    cname = str(answer.target).lower()
                    for pattern in vulnerable_patterns:
                        if pattern in cname:
                            takeover_vulns.append({
                                'type': 'Subdomain Takeover',
                                'severity': 'High',
                                'description': f'Potential subdomain takeover: {subdomain}',
                                'subdomain': subdomain,
                                'cname': cname,
                                'evidence': f'CNAME points to potentially vulnerable service: {pattern}'
                            })
                            break
                            
            except Exception as e:
                self.logger.debug(f"Subdomain takeover check error for {subdomain}: {e}")
                
        return takeover_vulns
        
    def calculate_risk_summary(self):
        """Calculate overall risk summary"""
        all_vulns = (
            self.results.get('web_vulnerabilities', []) +
            self.results.get('ssl_vulnerabilities', []) +
            self.results.get('service_vulnerabilities', []) +
            self.results.get('misconfigurations', [])
        )
        
        risk_summary = {'critical': 0, 'high': 0, 'medium': 0, 'low': 0, 'info': 0}
        
        for vuln in all_vulns:
            severity = vuln.get('severity', 'info').lower()
            if severity in risk_summary:
                risk_summary[severity] += 1
                
        self.results['risk_summary'] = risk_summary
        self.results['vulnerabilities'] = all_vulns
        
        return risk_summary
        
    def execute(self):
        """Execute the vulnerability identification stage"""
        self.logger.info("═══ STAGE 3: VULNERABILITY IDENTIFICATION ═══")
        
        try:
            # Get reconnaissance results
            from .reconnaissance import ReconnaissanceStage
            recon_results = getattr(self, 'recon_results', {})
            if 'ports' in recon_results:
                self.results.update(recon_results)
            
            # Step 1: SSL/TLS vulnerability checks
            self.check_ssl_vulnerabilities()
            
            # Step 2: Web vulnerability checks
            self.check_web_vulnerabilities()
            
            # Step 3: Service vulnerability checks
            self.check_service_vulnerabilities()
            
            # Step 4: Misconfiguration analysis
            self.analyze_misconfigurations()
            
            # Step 5: Calculate risk summary
            risk_summary = self.calculate_risk_summary()
            
            # Mark as successful
            self.results['success'] = True
            self.results['status'] = 'Vulnerability identification completed successfully'
            
            # Summary
            total_vulns = sum(risk_summary.values())
            critical_high = risk_summary['critical'] + risk_summary['high']
            
            self.logger.success(f"Vulnerability scan completed: {total_vulns} total findings, {critical_high} critical/high severity")
            
        except Exception as e:
            self.results['status'] = f'Vulnerability identification failed: {str(e)}'
            self.logger.error(f"Vulnerability identification stage failed: {e}")
            
        return self.results