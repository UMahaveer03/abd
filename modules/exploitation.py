"""
Stage 4: Exploitation
- Proof of concept development
- Safe exploitation attempts
- Documentation of findings
- Report generation
"""

import requests
import urllib.parse
import subprocess
import json
import os
from datetime import datetime
from .utils import ReportGenerator


class ExploitationStage:
    """Stage 4: Exploitation"""
    
    def __init__(self, target, config, logger):
        self.target = target
        self.config = config
        self.logger = logger
        self.results = {
            'stage': 'exploitation',
            'timestamp': datetime.now().isoformat(),
            'success': False,
            'status': 'Starting exploitation...',
            'exploits': [],
            'proof_of_concepts': [],
            'successful_exploits': [],
            'failed_exploits': [],
            'recommendations': [],
            'report_files': []
        }
        
    def develop_proof_of_concepts(self, vulnerabilities):
        """Develop proof of concepts for identified vulnerabilities"""
        self.logger.info("Developing proof of concepts...")
        
        pocs = []
        
        for vuln in vulnerabilities:
            vuln_type = vuln.get('type', '').lower()
            severity = vuln.get('severity', '').lower()
            
            # Only create PoCs for high/critical vulnerabilities
            if severity not in ['high', 'critical']:
                continue
                
            poc = {
                'vulnerability_id': len(pocs) + 1,
                'type': vuln['type'],
                'severity': vuln['severity'],
                'target': vuln.get('url', vuln.get('port', self.target)),
                'description': vuln['description'],
                'proof_of_concept': None,
                'exploitation_steps': [],
                'impact': '',
                'remediation': ''
            }
            
            # Develop specific PoCs based on vulnerability type
            if 'xss' in vuln_type:
                poc.update(self.create_xss_poc(vuln))
            elif 'sql injection' in vuln_type:
                poc.update(self.create_sqli_poc(vuln))
            elif 'file inclusion' in vuln_type:
                poc.update(self.create_lfi_poc(vuln))
            elif 'directory traversal' in vuln_type:
                poc.update(self.create_traversal_poc(vuln))
            elif 'ssl' in vuln_type or 'tls' in vuln_type:
                poc.update(self.create_ssl_poc(vuln))
            elif 'sensitive file' in vuln_type:
                poc.update(self.create_file_exposure_poc(vuln))
                
            if poc.get('proof_of_concept'):
                pocs.append(poc)
                
        self.results['proof_of_concepts'] = pocs
        return pocs
        
    def create_xss_poc(self, vuln):
        """Create XSS proof of concept"""
        return {
            'proof_of_concept': f"Reflected XSS in parameter '{vuln.get('parameter')}'",
            'exploitation_steps': [
                f"1. Navigate to: {vuln.get('url')}",
                f"2. Parameter '{vuln.get('parameter')}' reflects user input without encoding",
                f"3. Payload: {vuln.get('payload')}",
                "4. JavaScript execution confirmed in browser"
            ],
            'impact': 'Session hijacking, credential theft, defacement, malware distribution',
            'remediation': [
                'Implement proper input validation and output encoding',
                'Use Content Security Policy (CSP) headers',
                'Sanitize all user inputs',
                'Use HTTPOnly flags on session cookies'
            ]
        }
        
    def create_sqli_poc(self, vuln):
        """Create SQL injection proof of concept"""
        return {
            'proof_of_concept': f"SQL injection in parameter '{vuln.get('parameter')}'",
            'exploitation_steps': [
                f"1. Navigate to: {vuln.get('url')}",
                f"2. Parameter '{vuln.get('parameter')}' is vulnerable to SQL injection",
                f"3. Payload: {vuln.get('payload')}",
                f"4. Database error revealed: {vuln.get('evidence', 'SQL error detected')}"
            ],
            'impact': 'Data extraction, data modification, authentication bypass, potential RCE',
            'remediation': [
                'Use parameterized queries/prepared statements',
                'Implement proper input validation',
                'Apply principle of least privilege to database accounts',
                'Use stored procedures where appropriate',
                'Regular security testing and code review'
            ]
        }
        
    def create_lfi_poc(self, vuln):
        """Create LFI proof of concept"""
        return {
            'proof_of_concept': f"Local File Inclusion in parameter '{vuln.get('parameter')}'",
            'exploitation_steps': [
                f"1. Navigate to: {vuln.get('url')}",
                f"2. Parameter '{vuln.get('parameter')}' allows file inclusion",
                f"3. Payload: {vuln.get('payload')}",
                f"4. System file content retrieved: {vuln.get('evidence')}"
            ],
            'impact': 'Information disclosure, potential remote code execution, configuration exposure',
            'remediation': [
                'Implement strict input validation',
                'Use whitelist of allowed files',
                'Avoid user input in file operations',
                'Use proper file access controls',
                'Consider using a web application firewall'
            ]
        }
        
    def create_traversal_poc(self, vuln):
        """Create directory traversal proof of concept"""
        return {
            'proof_of_concept': f"Directory traversal vulnerability",
            'exploitation_steps': [
                f"1. Request: {vuln.get('url')}",
                f"2. Payload: {vuln.get('payload')}",
                f"3. System files accessible via path traversal",
                f"4. Evidence: {vuln.get('evidence')}"
            ],
            'impact': 'Unauthorized file access, information disclosure, potential system compromise',
            'remediation': [
                'Implement proper input validation',
                'Use canonical paths and validate file locations',
                'Implement proper access controls',
                'Avoid user input in file operations',
                'Regular security assessments'
            ]
        }
        
    def create_ssl_poc(self, vuln):
        """Create SSL/TLS vulnerability proof of concept"""
        return {
            'proof_of_concept': f"SSL/TLS vulnerability: {vuln.get('type')}",
            'exploitation_steps': [
                f"1. Connect to: {self.target}:{vuln.get('port')}",
                f"2. SSL/TLS vulnerability identified: {vuln.get('evidence')}",
                "3. Connection security compromised",
                "4. Man-in-the-middle attacks possible"
            ],
            'impact': 'Data interception, man-in-the-middle attacks, credential theft',
            'remediation': [
                'Update to TLS 1.2 or higher',
                'Disable weak cipher suites',
                'Implement HSTS headers',
                'Use strong SSL certificates',
                'Regular SSL configuration reviews'
            ]
        }
        
    def create_file_exposure_poc(self, vuln):
        """Create sensitive file exposure proof of concept"""
        return {
            'proof_of_concept': f"Sensitive file exposure: {vuln.get('file')}",
            'exploitation_steps': [
                f"1. Direct access to: {vuln.get('url')}",
                f"2. Sensitive file accessible without authentication",
                f"3. File content: {vuln.get('evidence')}",
                "4. Information disclosure confirmed"
            ],
            'impact': 'Configuration disclosure, credential exposure, system information leakage',
            'remediation': [
                'Remove sensitive files from web root',
                'Implement proper access controls',
                'Use .htaccess or web.config to deny access',
                'Regular file system audits',
                'Secure configuration management'
            ]
        }
        
    def attempt_safe_exploitation(self):
        """Attempt safe exploitation of identified vulnerabilities"""
        self.logger.info("Attempting safe exploitation...")
        
        successful_exploits = []
        failed_exploits = []
        pocs = self.results.get('proof_of_concepts', [])
        
        for poc in pocs:
            vuln_type = poc.get('type', '').lower()
            
            try:
                if 'xss' in vuln_type:
                    result = self.exploit_xss_safe(poc)
                elif 'sql injection' in vuln_type:
                    result = self.exploit_sqli_safe(poc)
                elif 'file inclusion' in vuln_type:
                    result = self.exploit_lfi_safe(poc)
                elif 'sensitive file' in vuln_type:
                    result = self.exploit_file_exposure_safe(poc)
                else:
                    result = {'success': False, 'reason': 'No safe exploitation method available'}
                    
                if result.get('success'):
                    successful_exploits.append({
                        'vulnerability_id': poc['vulnerability_id'],
                        'type': poc['type'],
                        'result': result,
                        'timestamp': datetime.now().isoformat()
                    })
                    self.logger.success(f"Successfully exploited: {poc['type']}")
                else:
                    failed_exploits.append({
                        'vulnerability_id': poc['vulnerability_id'],
                        'type': poc['type'],
                        'reason': result.get('reason', 'Unknown failure'),
                        'timestamp': datetime.now().isoformat()
                    })
                    
            except Exception as e:
                failed_exploits.append({
                    'vulnerability_id': poc['vulnerability_id'],
                    'type': poc['type'],
                    'reason': f'Exploitation error: {str(e)}',
                    'timestamp': datetime.now().isoformat()
                })
                self.logger.debug(f"Exploitation failed for {poc['type']}: {e}")
                
        self.results['successful_exploits'] = successful_exploits
        self.results['failed_exploits'] = failed_exploits
        
        return successful_exploits, failed_exploits
        
    def exploit_xss_safe(self, poc):
        """Safely exploit XSS vulnerability"""
        # For XSS, we just verify the payload is reflected
        # We don't execute actual malicious JavaScript
        try:
            # Extract URL from PoC
            if 'exploitation_steps' in poc and len(poc['exploitation_steps']) > 0:
                url_step = poc['exploitation_steps'][0]
                if 'Navigate to:' in url_step:
                    url = url_step.split('Navigate to:')[1].strip()
                    
                    headers = {'User-Agent': self.config.get('user_agent', 'ABD/1.0')}
                    response = requests.get(url, headers=headers, timeout=10, verify=False)
                    
                    # Check if our payload is reflected
                    if '<script>' in response.text:
                        return {
                            'success': True,
                            'method': 'Payload reflection verified',
                            'evidence': 'XSS payload reflected in response'
                        }
                        
            return {'success': False, 'reason': 'Could not verify XSS payload reflection'}
            
        except Exception as e:
            return {'success': False, 'reason': f'XSS exploitation error: {str(e)}'}
            
    def exploit_sqli_safe(self, poc):
        """Safely exploit SQL injection vulnerability"""
        # For SQLi, we just verify error-based detection
        # We don't perform actual data extraction
        try:
            # Extract URL from PoC
            if 'exploitation_steps' in poc and len(poc['exploitation_steps']) > 0:
                url_step = poc['exploitation_steps'][0]
                if 'Navigate to:' in url_step:
                    url = url_step.split('Navigate to:')[1].strip()
                    
                    headers = {'User-Agent': self.config.get('user_agent', 'ABD/1.0')}
                    response = requests.get(url, headers=headers, timeout=10, verify=False)
                    
                    # Check for SQL error indicators
                    sql_errors = ['mysql', 'ora-', 'postgresql', 'sqlite', 'sql server']
                    for error in sql_errors:
                        if error in response.text.lower():
                            return {
                                'success': True,
                                'method': 'SQL error detection',
                                'evidence': f'SQL error pattern found: {error}'
                            }
                            
            return {'success': False, 'reason': 'Could not verify SQL injection'}
            
        except Exception as e:
            return {'success': False, 'reason': f'SQLi exploitation error: {str(e)}'}
            
    def exploit_lfi_safe(self, poc):
        """Safely exploit LFI vulnerability"""
        # For LFI, we verify file content disclosure
        try:
            # Extract URL from PoC
            if 'exploitation_steps' in poc and len(poc['exploitation_steps']) > 0:
                url_step = poc['exploitation_steps'][0]
                if 'Navigate to:' in url_step:
                    url = url_step.split('Navigate to:')[1].strip()
                    
                    headers = {'User-Agent': self.config.get('user_agent', 'ABD/1.0')}
                    response = requests.get(url, headers=headers, timeout=10, verify=False)
                    
                    # Check for file content indicators
                    file_indicators = ['root:x:0:0:', '# localhost', 'Windows NT']
                    for indicator in file_indicators:
                        if indicator in response.text:
                            return {
                                'success': True,
                                'method': 'File content disclosure',
                                'evidence': f'File indicator found: {indicator}'
                            }
                            
            return {'success': False, 'reason': 'Could not verify file inclusion'}
            
        except Exception as e:
            return {'success': False, 'reason': f'LFI exploitation error: {str(e)}'}
            
    def exploit_file_exposure_safe(self, poc):
        """Safely exploit file exposure vulnerability"""
        # For file exposure, we verify file accessibility
        try:
            # Extract URL from PoC
            if 'exploitation_steps' in poc and len(poc['exploitation_steps']) > 0:
                url_step = poc['exploitation_steps'][0]
                if 'Direct access to:' in url_step:
                    url = url_step.split('Direct access to:')[1].strip()
                    
                    headers = {'User-Agent': self.config.get('user_agent', 'ABD/1.0')}
                    response = requests.get(url, headers=headers, timeout=10, verify=False)
                    
                    if response.status_code == 200 and len(response.content) > 0:
                        return {
                            'success': True,
                            'method': 'Direct file access',
                            'evidence': f'File accessible (HTTP {response.status_code})'
                        }
                        
            return {'success': False, 'reason': 'Could not access sensitive file'}
            
        except Exception as e:
            return {'success': False, 'reason': f'File exposure error: {str(e)}'}
            
    def generate_recommendations(self):
        """Generate security recommendations"""
        self.logger.info("Generating security recommendations...")
        
        recommendations = []
        pocs = self.results.get('proof_of_concepts', [])
        
        # Collect all remediation steps
        all_remediations = []
        for poc in pocs:
            if 'remediation' in poc:
                all_remediations.extend(poc['remediation'])
                
        # Remove duplicates and prioritize
        unique_remediations = list(set(all_remediations))
        
        # Categorize recommendations
        immediate_actions = []
        short_term_actions = []
        long_term_actions = []
        
        for remediation in unique_remediations:
            if any(keyword in remediation.lower() for keyword in ['disable', 'remove', 'update', 'patch']):
                immediate_actions.append(remediation)
            elif any(keyword in remediation.lower() for keyword in ['implement', 'configure', 'apply']):
                short_term_actions.append(remediation)
            else:
                long_term_actions.append(remediation)
                
        recommendations = {
            'immediate_actions': immediate_actions,
            'short_term_actions': short_term_actions,
            'long_term_actions': long_term_actions,
            'general_recommendations': [
                'Conduct regular security assessments',
                'Implement a Web Application Firewall (WAF)',
                'Establish security monitoring and incident response procedures',
                'Provide security training to development team',
                'Implement secure coding practices',
                'Regular penetration testing',
                'Security code review process'
            ]
        }
        
        self.results['recommendations'] = recommendations
        return recommendations
        
    def generate_reports(self):
        """Generate comprehensive security reports"""
        self.logger.info("Generating security reports...")
        
        report_files = []
        output_dir = self.config.get('output_dir', 'output')
        target_dir = os.path.join(output_dir, self.target.replace('.', '_'))
        
        # Compile all results
        all_results = {
            'target': self.target,
            'timestamp': datetime.now().isoformat(),
            'assessment_summary': {
                'total_vulnerabilities': len(self.results.get('proof_of_concepts', [])),
                'successful_exploits': len(self.results.get('successful_exploits', [])),
                'failed_exploits': len(self.results.get('failed_exploits', [])),
                'critical_findings': len([p for p in self.results.get('proof_of_concepts', []) if p.get('severity') == 'Critical']),
                'high_findings': len([p for p in self.results.get('proof_of_concepts', []) if p.get('severity') == 'High'])
            },
            'detailed_results': self.results
        }
        
        # Generate JSON report
        json_file = os.path.join(target_dir, f'exploitation_report_{datetime.now().strftime("%Y%m%d_%H%M%S")}.json')
        try:
            with open(json_file, 'w') as f:
                json.dump(all_results, f, indent=2)
            report_files.append(json_file)
            self.logger.success(f"JSON report generated: {json_file}")
        except Exception as e:
            self.logger.error(f"Failed to generate JSON report: {e}")
            
        # Generate HTML report
        html_file = os.path.join(target_dir, f'exploitation_report_{datetime.now().strftime("%Y%m%d_%H%M%S")}.html')
        try:
            report_generator = ReportGenerator(all_results, self.logger)
            report_generator.generate_html_report(html_file)
            report_files.append(html_file)
        except Exception as e:
            self.logger.error(f"Failed to generate HTML report: {e}")
            
        # Generate executive summary
        exec_summary_file = os.path.join(target_dir, f'executive_summary_{datetime.now().strftime("%Y%m%d_%H%M%S")}.txt')
        try:
            self.generate_executive_summary(exec_summary_file, all_results)
            report_files.append(exec_summary_file)
        except Exception as e:
            self.logger.error(f"Failed to generate executive summary: {e}")
            
        self.results['report_files'] = report_files
        return report_files
        
    def generate_executive_summary(self, filename, results):
        """Generate executive summary report"""
        summary = f"""
AUTOMATED BUG DISCOVERY (ABD) - EXECUTIVE SUMMARY
================================================

Target: {results['target']}
Assessment Date: {results['timestamp']}

SUMMARY OF FINDINGS
------------------
Total Vulnerabilities Identified: {results['assessment_summary']['total_vulnerabilities']}
Critical Risk Findings: {results['assessment_summary']['critical_findings']}
High Risk Findings: {results['assessment_summary']['high_findings']}

Successful Exploitations: {results['assessment_summary']['successful_exploits']}
Failed Exploitation Attempts: {results['assessment_summary']['failed_exploits']}

KEY FINDINGS
-----------
"""
        
        pocs = results['detailed_results'].get('proof_of_concepts', [])
        for i, poc in enumerate(pocs[:5], 1):  # Top 5 findings
            summary += f"""
{i}. {poc['type']} - {poc['severity']} Risk
   Description: {poc['description']}
   Impact: {poc.get('impact', 'Not specified')}
"""
            
        summary += f"""

RECOMMENDATIONS
--------------
"""
        
        recommendations = results['detailed_results'].get('recommendations', {})
        immediate = recommendations.get('immediate_actions', [])
        for action in immediate[:3]:  # Top 3 immediate actions
            summary += f"• {action}\n"
            
        summary += f"""

RISK ASSESSMENT
--------------
The security assessment identified {results['assessment_summary']['total_vulnerabilities']} vulnerabilities.
{results['assessment_summary']['critical_findings']} critical and {results['assessment_summary']['high_findings']} high-risk vulnerabilities require immediate attention.

For detailed technical information, please refer to the full technical report.

Generated by ABD (Automated Bug Discovery) v1.0
"""
        
        with open(filename, 'w') as f:
            f.write(summary)
            
        self.logger.success(f"Executive summary generated: {filename}")
        
    def execute(self):
        """Execute the exploitation stage"""
        self.logger.info("═══ STAGE 4: EXPLOITATION ═══")
        
        try:
            # Get vulnerability results from previous stage
            # This would normally be passed from the main application
            vulnerabilities = []
            
            # For now, we'll create a placeholder
            # In the full implementation, this would receive results from vulnerability stage
            
            # Step 1: Develop proof of concepts
            pocs = self.develop_proof_of_concepts(vulnerabilities)
            
            # Step 2: Attempt safe exploitation
            successful, failed = self.attempt_safe_exploitation()
            
            # Step 3: Generate recommendations
            self.generate_recommendations()
            
            # Step 4: Generate reports
            self.generate_reports()
            
            # Mark as successful
            self.results['success'] = True
            self.results['status'] = 'Exploitation stage completed successfully'
            
            # Summary
            poc_count = len(pocs)
            exploit_count = len(successful)
            report_count = len(self.results.get('report_files', []))
            
            self.logger.success(f"Exploitation completed: {poc_count} PoCs developed, {exploit_count} successful exploits, {report_count} reports generated")
            
        except Exception as e:
            self.results['status'] = f'Exploitation failed: {str(e)}'
            self.logger.error(f"Exploitation stage failed: {e}")
            
        return self.results